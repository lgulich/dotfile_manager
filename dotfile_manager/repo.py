from datetime import datetime
from pathlib import Path
import platform
import shutil

from dotfile_manager.config import BIN_PATH, SOURCE_FILE_PATH
from dotfile_manager.project import Project, InvalidProjectError


def get_os_name() -> str:
    """ Get the name of the operating system. """
    platform_name = platform.system()
    # TODO(lgulich): Find way to also determine linux distro.
    if platform_name == 'Linux':
        return 'ubuntu'
    if platform_name == 'Darwin':
        return 'macos'
    raise ValueError


def collect_projects(path: Path, os_name: str) -> dict[str, Project]:
    """ Collect all projects recursively in the passed folder. """
    projects = {}
    for project_path in sorted(x for x in path.glob('**/') if x.is_dir()):
        try:
            project = Project(project_path, os_name)
            if not project.is_disabled():
                projects[project.get_name()] = project
        except InvalidProjectError:
            continue

    print(f'Found {len(projects)} projects.')
    return projects


class Repo:
    """ Class used to represent a dotfile repository. """

    def __init__(self, path: Path, os_name: str = get_os_name()):
        self.path: Path = path
        self.projects: dict[str, Project] = collect_projects(path, os_name)

    def set_os_name(self, os_name: str):
        for project in self.projects.values():
            project.set_os_name(os_name)

    def get_path(self) -> Path:
        return self.path

    def install_all(self, verbose: bool = False):
        for name in self.projects:
            self.install(name, verbose)
        print('Successfully installed all projects.')

    def install(self, project_name: str, verbose: bool = False):
        project = self.projects[project_name]

        if project.is_disabled():
            print(f'Project {project_name} is disabled - Skipping.')
            return
        if project.is_installed():
            print(f'Project {project_name} is installed - Skipping.')
            return

        for requires_name in project.get_requires():
            self.install(requires_name, verbose)

        project.install(verbose=verbose)

    def setup_all(self):
        # Create folder into which all binaries will be symlinked.
        bin_path = self.path / BIN_PATH
        shutil.rmtree(bin_path, ignore_errors=True)
        bin_path.mkdir(parents=True)

        # Create file which contains everything that should be sourced.
        source_file_path = self.path / SOURCE_FILE_PATH
        source_file_path.unlink(missing_ok=True)
        source_file_path.parent.mkdir(parents=True, exist_ok=True)
        with open(source_file_path, 'a') as output_file:
            output_file.write(f'# Autogenerated on {datetime.now()}.\n')
            output_file.write('# shellcheck shell=sh\n\n')

            # Setup every project individually:
            for name, project in self.projects.items():
                if project.is_disabled():
                    print(f'Project {name} is disabled - Skipping.')
                    continue
                print(f'Setting up {project.get_name()}:')
                project.create_symbolic_links()
                project.create_bin(bin_path)
                project.add_sources(output_file)

        print(f'Successfully setup all projects. Sourcing script created at "{source_file_path}". '
              f'Binaries located at "{bin_path}".')
